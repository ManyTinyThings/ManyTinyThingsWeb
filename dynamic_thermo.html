<!DOCTYPE html>
<html>
<head>
    <title>Dynamic Thermodynamics</title>
    <script src="functions.js" type="text/javascript"></script>
    <script src="gl-matrix.js" type="text/javascript" charset="utf-8"></script>
    <script src="gl.js" type="text/javascript" charset="utf-8"></script>
    <!-- <script src="canvas.js" type="text/javascript" charset="utf-8"></script> -->
</head>
<body>
    <canvas id="canvas" width="500" height="400" style="border:1px solid black;"></canvas>
    <p>
        Energy = <output id="energy">?</output> (conserved) <br>
        Momentum = <output id="momentum">?</output> <br>
        Pressure = <output id="pressure">?</output> <br>
        Colors in left half = <output id="color">?</output> <br>
        Entropy = <output id="entropy">?</output> <br>
    </p>
    <p>
        Control time: <br>
        Backwards <input id="simulation_speed" type="range" value="1" min="-1" max="1" step="0.001" style="width: 300px;"> Forwards
    </p>
    <p>
        Number of balls: <br>
        1 <input id="ball_count" type="range" value="2", min="0", max="3", step="0.001"> 1000
    </p>
    <p>
        Ball radius: <br>
        1 <input id="ball_radius" type="range" value="3", min="1", max="10", step="0.001"> 10
    </p>
    <p>
        Gravity: <br>
        None <input id="gravity" type="range" value="0", min="0", max="0.0001", step="0.000001"> Strong
    </p>
    <p>
        Box size: <br>
        Tiny <input id="box_size" type="range" value="500", min="20", max="1000", step="0.001"> Huge
    </p>
    <p>
        Reset simulation to 
        <input type="button" value="Uniform" onclick="init(uniform_position, uniform_velocity, one_color)">
        <input type="button" value="Grouped" onclick="init(grouped_position, uniform_velocity, one_color)">
        <input type="button" value="Falling" 
            onclick="init(grouped_position, identical_velocity, one_color)">
        <input type="button" value="Two colors" 
            onclick="init(halves_position, uniform_velocity, two_colors)">
        <br>
        <label for="collision">Collision</label><input type="checkbox" id="collision">
    </p>
</body>

<script>

// Event handling


document.getElementById("simulation_speed").addEventListener("input", function() {
    simulation_speed = Number(this.value);
});

document.getElementById("collision").addEventListener("change", function(){
    collision_checking = this.checked;
})

document.getElementById("gravity").addEventListener("input", function(){
    gravity = Number(this.value);
})

document.getElementById("box_size").addEventListener("input", function(){
    canvas.width = Number(this.value);
    update_bounds();
})

document.getElementById("ball_count").addEventListener("input", function(){
    ball_count = Math.pow(10, Number(this.value));
    // TODO: do not reset
    init(uniform_position, uniform_velocity, one_color);
})

document.getElementById("ball_radius").addEventListener("input", function(){
    ball_radius = Number(this.value);
    update_bounds();
})

document.addEventListener('visibilitychange', function(event) {
    if (document.hidden) {
        pause();
    } else {
        resume();
    }
});

window.addEventListener("blur", function(){
    pause();
});
window.addEventListener("focus", function(){
    resume();
});

// Constants

var tau = 2*Math.PI;
var canvas = document.getElementById("canvas");

var max_speed = 0.1;
var ball_count = 100;
var ball_radius = 3;
var running = true;
var initially_together = true;
var initially_falling = false;
var collision_checking = false;
var gravity = 0;
var pressure_window_size = 1000;
var frame_duration = 33;

var collision_bounds;
var canvas_bounds;
var left_rect, right_rect;
                                    
                                              
// Simulation state

var balls;
var previous_time;
var simulation_speed = 1;
var request_frame_id;
var running_pressure = [];
var running_time = [];
var quadtree;

// Initialization

function grouped_position(ball_index, ball_count)
{
    var small_centered_rect = RectCenterWidthHeight(collision_bounds.center, 100, 100);
    return random_point_in_rectangle(small_centered_rect);
}

function uniform_position(ball_index, ball_count)
{
    return random_point_in_rectangle(collision_bounds);
}

function halves_position(ball_index, ball_count)
{
    if (ball_index < ball_count / 2)
    {
        return random_point_in_rectangle(left_rect);
    }
    else
    {
        return random_point_in_rectangle(right_rect);
    }
}

function uniform_velocity(ball_index, ball_count)
{
    var speed = random_in_interval(0, max_speed);
    var angle = random_in_interval(0, tau);
    return V2(Math.cos(angle), Math.sin(angle)).times(speed);
}

function identical_velocity(ball_index, ball_count) 
{
    return V2(0, max_speed);
}

function one_color(ball_index, ball_count) 
{
    return "black";
}

function two_colors(ball_index, ball_count)
{
    if (ball_index < ball_count / 2)
    {
        return "blue";
    }
    else
    {
        return "red";
    }
}

var Ball = function(position, velocity, color)
{
    this.position = position || V2();
    this.velocity = velocity || V2();
    this.color    = color    || "black";
}

Ball.prototype.bounds = function() {
    return RectCenterWidthHeight(this.position, ball_radius*2, ball_radius*2);
}

function init(position_function, velocity_function, color_function) 
{
    if (request_frame_id) {
        window.cancelAnimationFrame(request_frame_id);
        request_frame_id = undefined;
    }

    update_bounds();
    balls = [];
    for (var ball_index = 0; ball_index < ball_count; ball_index++) {
        var ball = new Ball(
            position_function(ball_index, ball_count), 
            velocity_function(ball_index, ball_count),
            color_function(ball_index, ball_count)
        );
        balls.push(ball);
    }
    
    previous_time = performance.now();
    request_frame_id = window.requestAnimationFrame(update);
}

function pause() 
{
    if (request_frame_id)
    {
        window.cancelAnimationFrame(request_frame_id);
        request_frame_id = undefined;
    }
}

function resume()
{
    if (!request_frame_id)
    {
        previous_time = performance.now();
        window.requestAnimationFrame(update);
    }
}

function update_bounds() {
    collision_bounds = RectLeftTopRightBottom(
        ball_radius, ball_radius, 
        canvas.width - ball_radius, 
        canvas.height - ball_radius
    );
    
    canvas_bounds = RectLeftTopWidthHeight(
        0, 0, canvas.width, canvas.height
    );
    
    right_rect = RectLeftTopRightBottom(
            canvas_bounds.center.x, canvas_bounds.top, 
            canvas_bounds.right, canvas_bounds.bottom);     
    left_rect = RectLeftTopRightBottom(
            canvas_bounds.left, canvas_bounds.top, 
            canvas_bounds.center.x, canvas_bounds.bottom);
    
    quadtree = new Quadtree(canvas_bounds);  
    
    resize_canvas();
}
                             
// Simulation

function collide(ball1, ball2)
{
    var vector_between_centers = ball1.position.minus(ball2.position);
    var quadrance = vector_between_centers.squared();
    if (quadrance < squared(2*ball_radius)) 
    {
        var distance_between_centers = Math.sqrt(quadrance);
        var overlap = 2*ball_radius - distance_between_centers;
        var normal = vector_between_centers.times(1 / distance_between_centers);
    
        // Move out of overlap
        // TODO: improve to perform correct collision
    
        var half_overlap_vector = normal.times(overlap / 2);
        ball1.position = ball1.position.plus(half_overlap_vector);
        ball2.position = ball2.position.minus(half_overlap_vector);
    
        // Elastic collision
    
        var relative_velocity = ball1.velocity.minus(ball2.velocity);
        var normal_velocity = relative_velocity.project_onto_normal(normal);
        ball1.velocity = ball1.velocity.minus(normal_velocity);
        ball2.velocity = ball2.velocity.plus(normal_velocity);
    }
}

function update(time) 
{
    var elapsed = time - previous_time;
    if (elapsed > 100)
    {
        elapsed = frame_duration;
    }
    var dt = elapsed * simulation_speed;
    previous_time = time;
    
    clear_canvas();
    
    var total_energy = 0;
    var total_momentum = V2();
    var total_pressure = 0;
    var color_counts = {};
    
    for (var ball of balls) 
    {
        draw_ball(ball);
        
        var gravity_acceleration = V2(0, -gravity)
        var deltaPosition = ball.velocity.times(dt)
          .plus( gravity_acceleration.times(0.5*squared(dt)) );
        ball.position = ball.position.plus(deltaPosition);
        ball.velocity = ball.velocity.plus(gravity_acceleration.times(dt));
        
        total_energy += ball.velocity.squared();
        total_momentum = total_momentum.plus(ball.velocity);
        
        if(is_point_in_rectangle(ball.position, left_rect))
        {
            color_counts[ball.color] = 1 + (color_counts[ball.color] || 0);
        }
    }
    
    for (var ball of balls)
    {
        // Collision with wall
        
        if (! is_point_in_rectangle(ball.position, collision_bounds))
        {
            var wall_normal = V2(0, 0);
            var overlap;

            if (ball.position.x < collision_bounds.left)
            {
                overlap = collision_bounds.left - ball.position.x;
                wall_normal = V2(1, 0);
            }
            else if (ball.position.x > collision_bounds.right)
            {
                overlap = ball.position.x - collision_bounds.right;
                wall_normal = V2(-1, 0);
            }
            else if (ball.position.y < collision_bounds.top)
            {
                overlap = collision_bounds.top - ball.position.y;
                wall_normal = V2(0, 1);
            }
            else if (ball.position.y > collision_bounds.bottom)
            {
                overlap = ball.position.y - collision_bounds.bottom;
                wall_normal = V2(0, -1);
            }
            
            // Move out of overlap
            
            ball.position = ball.position.plus(wall_normal.times(overlap));
            
            // Reflect velocity
            
            var projection = ball.velocity.project_onto_normal(wall_normal);
            ball.velocity = ball.velocity.minus(projection.times(2));
            
            total_pressure += projection.magnitude()
        }
    }
    
    
    // Collision with other balls
    if (collision_checking)
    {
        quadtree.clear();
        for (var ball of balls)
        {
            quadtree.add(ball);
        }
        quadtree.collide_all(collide);
    }
    
    // Measurements
    
    running_pressure.push(total_pressure);
    running_time.push(time)
    if (running_pressure.length > pressure_window_size)
    {
        running_pressure.shift();
        var initial_time = running_time.shift();
    }
    else
    {
        var initial_time = running_time[0];
    }

    var average_pressure = sum(running_pressure) / (time - initial_time);
    document.getElementById("pressure").value = average_pressure.toExponential(2);
    document.getElementById("energy").value = total_energy.toExponential(2);
    document.getElementById("momentum").value = 
        "(" + total_momentum.x.toExponential(2) + ", " + total_momentum.y.toExponential(2) + ")";
    var color_count_string = "";
    var entropy = 0;
    for (var color in color_counts) 
    {
        if (color_counts.hasOwnProperty(color)) 
        {
            var color_count = color_counts[color];
            var p = color_count/ball_count;
            entropy = microstate_entropy(p) + microstate_entropy(1 - p);
            color_count_string += color + ": " + color_count + " ";
        }
    }
    document.getElementById("color").value = color_count_string;
    document.getElementById("entropy").value = entropy.toExponential(2);
    
    if (running) 
    {
        request_frame_id = window.requestAnimationFrame(update);
    }
}

initGraphics(canvas);
init(uniform_position, uniform_velocity, one_color)

</script>

</html>