<!DOCTYPE html>
<html>
<head>
    <title>Dynamic Thermodynamics</title>
    <meta name="viewport" content="width=device-width">
    <script src="gl-matrix.js" type="text/javascript" charset="utf-8"></script>
    <script src="functions.js" type="text/javascript"></script>
    <script src="gl.js" type="text/javascript" charset="utf-8"></script>
    <!-- <script src="canvas.js" type="text/javascript" charset="utf-8"></script> -->
    <style type="text/css" media="screen">
        body {
            width: 500px;
            margin: 10px auto;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 300px;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 10px;
            background: #ddd;
            border: none;
            border-radius: 5px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: black;
            margin-top: -10px;
        }

        input[type=range]:focus {
            outline: none;
        }

        #canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="500" height="400"></canvas>
    <p>
        Energy = <output id="energy">?</output> (conserved) <br>
        Momentum = <output id="momentum">?</output> <br>
        Pressure = <output id="pressure">?</output> <br>
        Colors in left half = <output id="color">?</output> <br>
        Entropy = <output id="entropy">?</output> <br>
    </p>
    <p>
        Reset simulation to
        <input type="button" value="Uniform" onclick="init(uniformParticleGenerator)">
        <input type="button" value="Grouped" onclick="init(groupedParticleGenerator)">
        <input type="button" value="Falling" onclick="init(fallingParticleGenerator)">
        <input type="button" value="Two colors" onclick="init(twoColorParticleGenerator)">
        <input type="button" value="Lattice" onclick="init(latticeParticleGenerator)">
    </p>
    <p>
        Control time: <br>
        Backwards <input id="simulation_speed" type="range" value="1" min="-1" max="1" step="0.001"> Forwards
    </p>
    <p>
        Number of particles: <br>
        1 <input id="particle_count" type="range" value="2", min="0", max="3", step="0.001"> 1000
    </p>
    <p>
        Particle radius: <br>
        Tiny <input id="particle_radius" type="range" value="0.08", min="0.01", max="0.1", step="0.001"> Huge
    </p>
    <p>
        Gravity: <br>
        None <input id="gravity" type="range" value="0", min="0", max="2e-4", step="1e-8"> Strong
    </p>
    <p>
        Box size: <br>
        Tiny <input id="box_size" type="range" value="500", min="20", max="1000", step="0.001"> Huge
    </p>
    <p>
        <label for="collision">Collision</label><input type="checkbox" id="collision" checked>
        <label for="quadtree">Quadtree</label><input type="checkbox" id="quadtree" checked>
        <label for="trajectory">Draw trajectory</label><input type="checkbox" id="trajectory">
    </p>
</body>

<script>

// Event handling


document.getElementById("collision").addEventListener("change", function(){
    collision_enabled = this.checked;
});

document.getElementById("quadtree").addEventListener("change", function(){
    quadtree_enabled = this.checked;
    quadtree.clear();
});

document.getElementById("trajectory").addEventListener("change", function(){
    trajectory_enabled = this.checked;
    updateTrajectory();
});

document.getElementById("simulation_speed").addEventListener("input", function() {
    simulation_speed = Number(this.value);
});

document.getElementById("gravity").addEventListener("input", function(){
    var strength = Number(this.value);
    var angle = 0; // down
    vec2.set(gravity_acceleration, strength * Math.sin(angle), - strength * Math.cos(angle));
})

document.getElementById("box_size").addEventListener("input", function(){
    canvasWidth = Number(this.value);
    canvas.style.marginLeft = ((document.body.clientWidth - canvasWidth) / 2) + "px";
    updateBounds();
})

document.getElementById("particle_count").addEventListener("input", function(){
    particleCount = Math.round(Math.pow(10, Number(this.value)));
    updateParticleCount(particleCount);
})

document.getElementById("particle_radius").addEventListener("input", function(){
    particle_radius = Number(this.value);
    updateBounds();
})


var canvas = document.getElementById("canvas");
var canvasWidth = canvas.width;
var canvasHeight = canvas.height;

canvas.addEventListener("click", function(){
    if (request_frame_id)
    {
        paused_by_user = true;
        pause();
    }
    else
    {
        paused_by_user = false;
        resume();
    }
})

// Pause when switching tabs, seems reasonable

document.addEventListener('visibilitychange', function(event) {
    if (document.hidden)
    {
        pause();
    }
    else if (!paused_by_user)
    {
        resume();
    }
});

// Pause when switching windows, annoying during development

// window.addEventListener("blur", function(){
//     pause();
// });
// window.addEventListener("focus", function(){
//     resume();
// });

// Variables

var tau = 2*Math.PI;

var max_speed = 0.001;
var particle_radius = 0.08;
var running = true;
var initially_together = true;
var initially_falling = false;
var collision_enabled = false;
var gravity_acceleration = vec2.create();
var pressure_window_size = 1000;
var quadtree_enabled = true;
var frame_duration = 33;

var box_bounds = new Rect();
var collision_bounds = new Rect();
var left_rect = new Rect();
var right_rect = new Rect();


// Simulation state

var particleGenerator = uniformParticleGenerator;
var particleCount = 91;
var particles = [];
var trajectory = [];
var trajectory_enabled = false;

var paused_by_user = false;
var previous_time;
var simulation_speed = 1;
var request_frame_id;
var running_pressure = [];
var running_time = [];
var quadtree;


// Particle object

var Particle = function(position, velocity, color)
{
    this.position = position || vec2.create();
    this.velocity = velocity || vec2.create();
    this.acceleration = vec2.create();
    this.color    = color    || {name: "black", rgba: [0, 0, 0, 1]};
    this.bounds   = new Rect();
    this.radius   = 1;
}

Particle.prototype.updateBounds = function()
{
    this.bounds.setCenterWidthHeight(this.position, particle_radius*2, particle_radius*2);
    return this.bounds;
}

//
// Initialization
//

function grouped_position(particleIndex)
{
    var small_centered_rect = new Rect().setCenterWidthHeight(
        collision_bounds.center, collision_bounds.width / 5, collision_bounds.height / 5
    );
    return randomPointInRect(small_centered_rect);
}

function uniform_position(particleIndex)
{
    return randomPointInRect(collision_bounds);
}

function halves_position(particleIndex)
{
    if (particleIndex % 2 == 0)
    {
        return randomPointInRect(left_rect);
    }
    else
    {
        return randomPointInRect(right_rect);
    }
}

vec2.setPolar = function(out, radius, angle)
{
    var x = radius * Math.cos(angle);
    var y = radius * Math.sin(angle);
    return vec2.set(out, x, y);
}

var triangular_lattice_position = function(){
    
    var latticeX = vec2.create();
    var latticeY = vec2.create();
    
    return function (particleIndex)
    {
        // NOTE: this is the formula for triangular numbers inverted
        var triangularNumber = Math.floor((Math.sqrt(8*particleIndex + 1) - 1) / 2);
        var rest = particleIndex - triangularNumber * (triangularNumber + 1) / 2;
        var integerX = rest;
        var integerY = triangularNumber - rest;
        var latticeSpacing = 2 * particle_radius;
        vec2.setPolar(latticeX, latticeSpacing * integerX, 0);
        vec2.setPolar(latticeY, latticeSpacing * integerY, tau / 6);
        return vec2.add(vec2.create(), latticeX, latticeY);
    }
}

var hexagonal_lattice_position = function(){
    
    var latticeX = vec2.create();
    var latticeY = vec2.create();
    
    return function (particleIndex)
    {
        // NOTE: this adds the particles in a spiral by figuring out their coordinates in 
        // one of 6 triangular lattices
        if (particleIndex == 0) {
            return vec2.create();
        }
        var k = particleIndex - 1;
        var layer = Math.floor((Math.sqrt(8*(k / 6) + 1) - 1) / 2) + 1; // NOTE: 1-indexed
        var rest = k - 6 * layer * (layer - 1) / 2;
        var triangleIndex = Math.floor(rest / layer);
        var integerX = layer;
        var integerY = rest % layer;
        var latticeSpacing = 2 * particle_radius;
        var rotationAngle = triangleIndex * tau/6;
        vec2.setPolar(latticeX, latticeSpacing * integerX, rotationAngle);
        var shape = 2; // 1: spiral, 2: hexagon
        vec2.setPolar(latticeY, latticeSpacing * integerY, rotationAngle + shape * tau/6);
        return vec2.add(vec2.create(), latticeX, latticeY);
    }
}();

function no_velocity(particleIndex)
{
    return vec2.create();
}

function uniform_velocity(particleIndex)
{
    var speed = random_in_interval(0, max_speed);
    var angle = random_in_interval(0, tau);
    return vec2.fromValues(speed * Math.cos(angle), speed * Math.sin(angle));
}

function identical_velocity(particleIndex)
{
    return vec2.fromValues(0, -max_speed);
}

function one_color(particleIndex)
{
    return {name: "black", rgba: [0, 0, 0, 1]};
}

function two_colors(particleIndex)
{
    if (particleIndex % 2 == 0)
    {
        return {name: "black", rgba: [0, 0, 0, 1]};
    }
    else
    {
        return {name: "red", rgba: [1, 0, 0, 1]};
    }
}

//
// particle generators
//

function uniformParticleGenerator(particleIndex)
{
    return new Particle(
        uniform_position(particleIndex),
        uniform_velocity(particleIndex),
        one_color(particleIndex)
    );
}

function groupedParticleGenerator(particleIndex)
{
    return new Particle(
        grouped_position(particleIndex),
        uniform_velocity(particleIndex),
        one_color(particleIndex)
    );
}

function fallingParticleGenerator(particleIndex)
{
    return new Particle(
        grouped_position(particleIndex),
        identical_velocity(particleIndex),
        one_color(particleIndex)
    );
}

function twoColorParticleGenerator(particleIndex)
{
    return new Particle(
        halves_position(particleIndex),
        uniform_velocity(particleIndex),
        two_colors(particleIndex)
    );
}

function latticeParticleGenerator(particleIndex)
{
    return new Particle(
        hexagonal_lattice_position(particleIndex),
        no_velocity(particleIndex),
        one_color(particleIndex)
    );
}

function updateParticleCount(newParticleCount)
{
    var particleCount = particles.length;
    if (newParticleCount == particleCount)
    {
        return;
    }
    else if (newParticleCount < particleCount)
    {
        particles.splice(newParticleCount, Number.MAX_VALUE);
    }
    else
    {
        for (var particleIndex = particleCount;
             particleIndex < newParticleCount;
             ++particleIndex)
        {
            particles.push(particleGenerator(particleIndex))
        }
        // TODO: move particles out of each other so that no overlaps occur
        
    }
    particleCount = newParticleCount;

    draw();
}

function updateTrajectory()
{
    trajectory = [];
    if (trajectory_enabled)
    {
        particles[0].color = {name: "blue", rgba: [0, 0, 1, 1]};
    }
    else
    {
        particles[0].color = particleGenerator(0).color;
    }
    draw();
}

function init(newParticleGenerator)
{
    if (request_frame_id) {
        window.cancelAnimationFrame(request_frame_id);
        request_frame_id = undefined;
    }

    updateBounds();

    particleGenerator = newParticleGenerator || latticeParticleGenerator;
    particles = [];
    updateParticleCount(particleCount);

    updateTrajectory();

    previous_time = 0;
    request_frame_id = window.requestAnimationFrame(update);
}

function pause()
{
    if (request_frame_id)
    {
        window.cancelAnimationFrame(request_frame_id);
        request_frame_id = undefined;
    }
}

function resume()
{
    if (!request_frame_id)
    {
        previous_time = 0;
        window.requestAnimationFrame(update);
    }
}

function updateBounds() {

    // retina stuff

    canvas.style.width = canvasWidth + "px";
    canvas.style.height = canvasHeight + "px";

    var devicePixelRatio = window.devicePixelRatio || 1;
    canvas.width = canvasWidth * devicePixelRatio;
    canvas.height = canvasHeight * devicePixelRatio;

    // boxes

    var aspectRatio = canvas.width / canvas.height;
    var origin = vec2.fromValues(0, 0);

    box_bounds.setCenterWidthHeight(
        origin, 2*aspectRatio, 2
    );

    collision_bounds.setCenterWidthHeight(
        origin, 2*(aspectRatio - particle_radius), 2*(1 - particle_radius)
    );

    right_rect.setLeftTopRightBottom(
            box_bounds.center[0], box_bounds.top,
            box_bounds.right, box_bounds.bottom);
    left_rect.setLeftTopRightBottom(
            box_bounds.left, box_bounds.top,
            box_bounds.center[0], box_bounds.bottom);

    quadtree = new Quadtree(box_bounds);

    resize_canvas();

    draw();
}

function lennardJonesEnergy(invDistance, bondEnergy, separation)
{
    // TODO: truncate and shift, see wikipedia
    var a = separation * invDistance;
    var a6 = Math.pow(a, 6);
    var shape = a6*a6 - 2*a6;
    return bondEnergy * shape;
}

function lennardJonesForce(invDistance, bondEnergy, separation)
{
    var a = separation * invDistance;
    var a6 = Math.pow(a, 6);
    var shape = 12 * invDistance * (a6*a6 - a6);
    return bondEnergy * shape;
}

// Simulation
var collide = function(){

  var relative_position = vec2.create();
  var relative_velocity = vec2.create();

  return function(particle1, particle2)
  {
      vec2.subtract(relative_position, particle1.position, particle2.position);
      var quadrance = vec2.squaredLength(relative_position);
      if (quadrance < squared(2*particle_radius))
      {
          var distance_between_centers = Math.sqrt(quadrance);
          var overlap = 2*particle_radius - distance_between_centers;
          var normal = vec2.scale(relative_position, relative_position, 1 / distance_between_centers);

          // Move out of overlap
          // TODO: improve to perform correct collision
          // TODO: use a continuous force instead of hard spheres

          vec2.scaleAndAdd(particle1.position, particle1.position, normal, overlap / 2);
          vec2.scaleAndAdd(particle2.position, particle2.position, normal, - overlap / 2);

          // Elastic collision

          vec2.subtract(relative_velocity, particle1.velocity, particle2.velocity);
          var delta_velocity = vec2.projectOntoNormal(relative_velocity, relative_velocity, normal);
          vec2.sub(particle1.velocity, particle1.velocity, delta_velocity);
          vec2.add(particle2.velocity, particle2.velocity, delta_velocity);
      }
  }
}();

function draw()
{
    clear_canvas();

    // update trajectory
    if (trajectory_enabled)
    {
        trajectory.push(particles[0].position[0], particles[0].position[1]);
        drawTrajectory(trajectory, particles[0].color);
    }

    drawParticles(particles, particle_radius);
}

var update = function(){

  var relative_position = vec2.create(); 
  
  var total_momentum = vec2.create();
  var wall_normal = vec2.create();
  var projection = vec2.create();

  return function(time)
  {
      var elapsed = time - previous_time;
      if ((elapsed > 100) || (elapsed <= 0))
      {
          elapsed = frame_duration;
      }
      var dt = elapsed * simulation_speed * 0.01;
      previous_time = time;

      var total_energy = 0;
      var total_pressure = 0;
      vec2.set(total_momentum, 0, 0);
      var color_counts = {};
      
      var mass = 1;

      for (var particleIndex = 0;
          particleIndex < particles.length;
          ++particleIndex)
      {
          var particle = particles[particleIndex];
          
          // velocity verlet
          
          vec2.scaleAndAdd(particle.velocity, particle.velocity, particle.acceleration, 0.5 * dt);
          vec2.scaleAndAdd(particle.position, particle.position, particle.velocity, dt);
          
          // set up acceleration before next loop
          vec2.copy(particle.acceleration, gravity_acceleration);
      }

      // Calculate forces
      
      for (var i = 0; i < particles.length; ++i)
      {
          var particle = particles[i];
          
          for (var j = 0; j < i; ++j)
          {
              var otherParticle = particles[j];
              // TODO: use quadtree with given cutoff distance
              
              var bondEnergy = 0.0001;
              var separation = particle_radius * (particle.radius + otherParticle.radius);
              
              vec2.subtract(relative_position, otherParticle.position, particle.position);
              var invDistance = 1 / vec2.length(relative_position);
              var force = lennardJonesForce(invDistance, bondEnergy, separation);
              total_energy += lennardJonesEnergy(invDistance, bondEnergy, separation);
              
              var acceleration_direction = vec2.normalize(relative_position, relative_position);
              var acceleration_magnitude = force / mass;
              vec2.scaleAndAdd(particle.acceleration, particle.acceleration, acceleration_direction, - acceleration_magnitude);
              vec2.scaleAndAdd(otherParticle.acceleration, otherParticle.acceleration, acceleration_direction, acceleration_magnitude);
          }
      }
      
      for (var particleIndex = 0;
          particleIndex < particles.length;
          ++particleIndex)
      {
          var particle = particles[particleIndex];
          
          // finish velocity verlet
          vec2.scaleAndAdd(particle.velocity, particle.velocity, particle.acceleration, 0.5 * dt);
          
          // calculate quantities
          if(left_rect.containsPoint(particle.position))
          {
              color_counts[particle.color.name] = 1 + (color_counts[particle.color.name] || 0);
          }
          total_energy += 0.5*vec2.squaredLength(particle.velocity);
          total_energy += vec2.dot(particle.position, gravity_acceleration);
          
          vec2.scaleAndAdd(total_momentum, total_momentum, particle.velocity, mass);
          
          
          // Collision with wall

          if (! collision_bounds.containsPoint(particle.position))
          {
              var overlap;

              if (particle.position[0] < collision_bounds.left)
              {
                  overlap = collision_bounds.left - particle.position[0];
                  vec2.set(wall_normal, 1, 0);
              }
              else if (particle.position[0] > collision_bounds.right)
              {
                  overlap = particle.position[0] - collision_bounds.right;
                  vec2.set(wall_normal, -1, 0);
              }
              else if (particle.position[1] < collision_bounds.top)
              {
                  overlap = collision_bounds.top - particle.position[1];
                  vec2.set(wall_normal, 0, 1);
              }
              else if (particle.position[1] > collision_bounds.bottom)
              {
                  overlap = particle.position[1] - collision_bounds.bottom;
                  vec2.set(wall_normal, 0, -1);
              }

              // Move out of overlap

              vec2.scaleAndAdd(particle.position, particle.position, wall_normal, overlap);

              // Reflect velocity

              vec2.projectOntoNormal(projection, particle.velocity, wall_normal);
              vec2.scaleAndAdd(particle.velocity, particle.velocity, projection, -2);

              total_pressure += vec2.length(projection);
          }
      }


      // Collision with other particles
      if (collision_enabled)
      {
          if (quadtree_enabled)
          {
              quadtree.clear();
              for (var particleIndex = 0;
                  particleIndex < particles.length;
                  ++particleIndex)
              {
                  var particle = particles[particleIndex];
                  particle.updateBounds();
                  quadtree.add(particle);
              }
              quadtree.collide_all(collide);
          }
          else
          {
              for (var i = 0; i < particles.length; ++i)
              {
                  for (var j = 0; j < i; ++j)
                  {
                      collide(particles[i], particles[j]);
                  }
              }
          }
      }

      // Drawing

      draw();

      // Measurements

      running_pressure.push(total_pressure);
      running_time.push(time)
      if (running_pressure.length > pressure_window_size)
      {
          running_pressure.shift();
          var initial_time = running_time.shift();
      }
      else
      {
          var initial_time = running_time[0];
      }

      var average_pressure = sum(running_pressure) / (time - initial_time);
      document.getElementById("pressure").value = average_pressure.toExponential(2);
      document.getElementById("energy").value = total_energy.toExponential(2);
      document.getElementById("momentum").value =
          ["(", total_momentum[0].toExponential(2),
           ", ", total_momentum[1].toExponential(2), ")"].join("");
      var color_count_string_array = [];
      var entropy = 0;
      for (var color in color_counts)
      {
          if (color_counts.hasOwnProperty(color))
          {
              var color_count = color_counts[color];
              var p = color_count/particles.length;
              entropy = microstate_entropy(p) + microstate_entropy(1 - p);
              color_count_string_array.push(color, ": ", color_count, " ");
          }
      }
      document.getElementById("color").value = color_count_string_array.join("");
      document.getElementById("entropy").value = entropy.toExponential(2);

      if (running)
      {
          request_frame_id = window.requestAnimationFrame(update);
      }
  }
}();


initGraphics(canvas);
init()

</script>

</html>
