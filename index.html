<!DOCTYPE html>
<html>
<head>
    <title>Dynamic Thermodynamics</title>
    <meta name="viewport" content="width=device-width">
    <script src="gl-matrix.js" type="text/javascript" charset="utf-8"></script>
    <script src="functions.js" type="text/javascript"></script>
    <script src="gl.js" type="text/javascript" charset="utf-8"></script>
    <!-- <script src="canvas.js" type="text/javascript" charset="utf-8"></script> -->
    <style type="text/css" media="screen">
        body {
            width: 500px;
            margin: 10px auto;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 300px;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 10px;
            background: #ddd;
            border: none;
            border-radius: 5px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: black;
            margin-top: -10px;
        }

        input[type=range]:focus {
            outline: none;
        }

        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <div id="simulation"></div>
    <p>
        Energy = <output id="energy">?</output> <br>
        Total momentum = <output id="momentum">?</output> <br>
        Pressure = <output id="pressure">?</output> <br>
        Colors in left half = <output id="color">?</output> <br>
        Entropy = <output id="entropy">?</output> <br>
    </p>
    <p>
        Reset simulation to
        <input type="button" value="Uniform" onclick="init(uniformParticleGenerator)">
        <input type="button" value="Grouped" onclick="init(groupedParticleGenerator)">
        <input type="button" value="Falling" onclick="init(fallingParticleGenerator)">
        <input type="button" value="Two colors" onclick="init(twoColorParticleGenerator)">
        <input type="button" value="Lattice" onclick="init(latticeParticleGenerator)">
    </p>
    <p>
        <label for="collision">Collision</label><input type="checkbox" id="collision" checked>
        <label for="quadtree">Quadtree</label><input type="checkbox" id="quadtree" checked>
        <label for="trajectory">Draw trajectory</label><input type="checkbox" id="trajectory">
    </p>
</body>

<script>

// Event handling


document.getElementById("collision").addEventListener("change", function(){
    collision_enabled = this.checked;
});

document.getElementById("quadtree").addEventListener("change", function(){
    quadtree_enabled = this.checked;
    quadtree.clear();
});

document.getElementById("trajectory").addEventListener("change", function(){
    trajectory_enabled = this.checked;
    updateTrajectory();
});



// Pause when switching tabs, seems reasonable

// TODO: should pause all sims (right now crashes)

document.addEventListener('visibilitychange', function(event) {
    if (document.hidden)
    {
        pauseSimulation();
    }
    else if (!paused_by_user)
    {
        resumeSimulation();
    }
});

// Pause when switching windows, annoying during development

// window.addEventListener("blur", function(){
//     pause();
// });
// window.addEventListener("focus", function(){
//     resume();
// });

// Creating UI

function combineWithDefaults(opts, defaults)
{
    for (var key in defaults) {
        if (! opts.hasOwnProperty(key)) {
            opts[key] = defaults[key];
        }
    }
}

function createSlider(simulation, opts)
{
    combineWithDefaults(opts, {
        minLabel: String(opts.min),
        maxLabel: String(opts.max),
        snapBack: false,
        function: function(x){ return x; },
    });
    
    // set up slider element
    
    var slider = document.createElement("input");
    slider.setAttribute("type", "range");
    slider.setAttribute("value", opts.initial);
    slider.setAttribute("min", opts.min);
    slider.setAttribute("max", opts.max);
    var step = opts.step || (opts.max - opts.min) / 1000;
    slider.setAttribute("step", step);
    
    // set up presentation elements
    
    var p = document.createElement("p");
    simulation.controlsDiv.appendChild(p);
    p.appendChild(document.createTextNode(opts.label));
    p.appendChild(document.createElement("br"));
    p.appendChild(document.createTextNode(opts.minLabel));
    p.appendChild(slider);
    p.appendChild(document.createTextNode(opts.maxLabel));
    
    // set up callbacks
    
    simulation.parameters[opts.name] = opts.function(opts.initial);
    
    slider.addEventListener("input", function() {
        simulation.parameters[opts.name] = opts.function(Number(this.value));
    });
    
    if (opts.snapBack)
    {
        slider.addEventListener("change", function() {
            this.value = opts.initial;
            simulation.parameters[opts.name] = opts.function(opts.initial);
        });
    }
}


// Constants

var tau = 2*Math.PI;



// Particle object

var Particle = function(position, velocity, color)
{
    this.position = position || vec2.create();
    this.velocity = velocity || vec2.create();
    this.acceleration = vec2.create();
    this.color    = color    || {name: "black", rgba: [0, 0, 0, 1]};
    this.bounds   = new Rect();
    this.radius   = 1;
}

Particle.prototype.updateBounds = function()
{
    this.bounds.setCenterWidthHeight(this.position, radiusScaling*2, radiusScaling*2);
    return this.bounds;
}

//
// Initialization
//

function grouped_position(simulation, particleIndex)
{
    var collision_bounds = simulation.collision_bounds;
    var small_centered_rect = new Rect().setCenterWidthHeight(
        collision_bounds.center, collision_bounds.width / 5, collision_bounds.height / 5
    );
    return randomPointInRect(small_centered_rect);
}

function uniform_position(simulation, particleIndex)
{
    return randomPointInRect(simulation.collision_bounds);
}

function halves_position(simulation, particleIndex)
{
    if (particleIndex % 2 == 0)
    {
        return randomPointInRect(simulation.left_rect);
    }
    else
    {
        return randomPointInRect(simulation.right_rect);
    }
}

vec2.setPolar = function(out, radius, angle)
{
    var x = radius * Math.cos(angle);
    var y = radius * Math.sin(angle);
    return vec2.set(out, x, y);
}

var triangular_lattice_position = function(){
    
    var latticeX = vec2.create();
    var latticeY = vec2.create();
    
    return function (simulation, particleIndex)
    {
        // NOTE: this is the formula for triangular numbers inverted
        var triangularNumber = Math.floor((Math.sqrt(8*particleIndex + 1) - 1) / 2);
        var rest = particleIndex - triangularNumber * (triangularNumber + 1) / 2;
        var integerX = rest;
        var integerY = triangularNumber - rest;
        var latticeSpacing = 2 * simulation.parameters.radiusScaling;
        vec2.setPolar(latticeX, latticeSpacing * integerX, 0);
        vec2.setPolar(latticeY, latticeSpacing * integerY, tau / 6);
        return vec2.add(vec2.create(), latticeX, latticeY);
    }
}

var hexagonal_lattice_position = function(){
    
    var latticeX = vec2.create();
    var latticeY = vec2.create();
    
    return function (simulation, particleIndex)
    {
        // NOTE: this adds the particles in a spiral by figuring out their coordinates in 
        // one of 6 triangular lattices
        if (particleIndex == 0) {
            return vec2.create();
        }
        var k = particleIndex - 1;
        var layer = Math.floor((Math.sqrt(8*(k / 6) + 1) - 1) / 2) + 1; // NOTE: 1-indexed
        var rest = k - 6 * layer * (layer - 1) / 2;
        var triangleIndex = Math.floor(rest / layer);
        var integerX = layer;
        var integerY = rest % layer;
        var latticeSpacing = 2 * simulation.parameters.radiusScaling;
        var rotationAngle = triangleIndex * tau/6;
        vec2.setPolar(latticeX, latticeSpacing * integerX, rotationAngle);
        var shape = 2; // 1: spiral, 2: hexagon
        vec2.setPolar(latticeY, latticeSpacing * integerY, rotationAngle + shape * tau/6);
        return vec2.add(vec2.create(), latticeX, latticeY);
    }
}();

function no_velocity(simulation, particleIndex)
{
    return vec2.create();
}

function uniform_velocity(simulation, particleIndex)
{
    var speed = random_in_interval(0, simulation.parameters.max_initial_speed);
    var angle = random_in_interval(0, tau);
    return vec2.fromValues(speed * Math.cos(angle), speed * Math.sin(angle));
}

function identical_velocity(simulation, particleIndex)
{
    return vec2.fromValues(0, - simulation.parameters.max_initial_speed);
}

function one_color(simulation, particleIndex)
{
    return {name: "black", rgba: [0, 0, 0, 1]};
}

function two_colors(simulation, particleIndex)
{
    if (particleIndex % 2 == 0)
    {
        return {name: "black", rgba: [0, 0, 0, 1]};
    }
    else
    {
        return {name: "red", rgba: [1, 0, 0, 1]};
    }
}

//
// particle generators
//

function uniformParticleGenerator(simulation, particleIndex)
{
    return new Particle(
        uniform_position(simulation, particleIndex),
        uniform_velocity(simulation, particleIndex),
        one_color(simulation, particleIndex)
    );
}

function groupedParticleGenerator(simulation, particleIndex)
{
    return new Particle(
        grouped_position(simulation, particleIndex),
        uniform_velocity(simulation, particleIndex),
        one_color(simulation, particleIndex)
    );
}

function fallingParticleGenerator(simulation, particleIndex)
{
    return new Particle(
        grouped_position(simulation, particleIndex),
        identical_velocity(simulation, particleIndex),
        one_color(simulation, particleIndex)
    );
}

function twoColorParticleGenerator(simulation, particleIndex)
{
    return new Particle(
        halves_position(simulation, particleIndex),
        uniform_velocity(simulation, particleIndex),
        two_colors(simulation, particleIndex)
    );
}

function latticeParticleGenerator(simulation, particleIndex)
{
    return new Particle(
        hexagonal_lattice_position(simulation, particleIndex),
        no_velocity(simulation, particleIndex),
        one_color(simulation, particleIndex)
    );
}

function updateParticleCount(simulation, newParticleCount)
{
    if (newParticleCount == simulation.particleCount)
    {
        return;
    }
    else if (newParticleCount < simulation.particleCount)
    {
        particles.splice(newParticleCount, Number.MAX_VALUE);
    }
    else
    {
        for (var particleIndex = simulation.particleCount;
             particleIndex < newParticleCount;
             ++particleIndex)
        {
            simulation.particles.push(simulation.particleGenerator(simulation, particleIndex))
        }
        // TODO: move particles out of each other so that no overlaps occur
    }
    simulation.particleCount = newParticleCount;

    draw(simulation);
}

function updateTrajectory(simulation, trajectory_enabled)
{
    simulation.trajectory = [];
    if (simulation.trajectory_enabled)
    {
        simulation.particles[0].color = {name: "blue", rgba: [0, 0, 1, 1]};
    }
    else
    {
        simulation.particles[0].color = simulation.particleGenerator(simulation, 0).color;
    }
    simulation.trajectory_enabled = trajectory_enabled;
    
    draw(simulation);
}

function createSimulation(divId, width, height)
{
    var simulation = {};
    
    
    simulation.running = true;
    simulation.pausedByUser = false;
    simulation.previousTime = 0;
    
    simulation.particles = [];
    simulation.particleCount = 0;
    simulation.particleGenerator = latticeParticleGenerator;

    simulation.quadTree = undefined;
    
    simulation.trajectoryEnabled = false;
    simulation.trajectory = [];
    
    simulation.runningPressure = [];
    simulation.runningTime = [];
    
    simulation.box_bounds = new Rect();
    simulation.collision_bounds = new Rect();
    simulation.left_rect = new Rect();
    simulation.right_rect = new Rect();
    
    simulation.parameters = {
        max_initial_speed: 0.001,
        collision_enabled: false,
        pressure_window_size: 1000,
        quadtree_enabled: true,
        frame_duration: 33,
    };
    

    // set up HTML elements
    simulation.div = document.getElementById(divId);
    
    simulation.canvas = document.createElement("canvas");
    simulation.canvas.setAttribute("width", width);
    simulation.canvas.setAttribute("height", height);
    simulation.div.appendChild(simulation.canvas);
    
    simulation.controlsDiv = document.createElement("div");
    simulation.controlsDiv.setAttribute("class", "controls");
    simulation.div.appendChild(simulation.controlsDiv);
    
    simulation.canvas.addEventListener("click", function(){
        if (simulation.requestFrameId)
        {
            simulation.paused_by_user = true;
            pauseSimulation(simulation);
        }
        else
        {
            simulation.paused_by_user = false;
            resumeSimulation(simulation);
        }
    });
    
    // setup controls and meters
    
    createSlider(simulation, {
        name: "delta_temperature",
        label: "Control temperature:",
        initial: 1,
        min: 0.97, minLabel: "Colder",
        max: 1.03, maxLabel: "Warmer", 
        snapBack: true,
    });
    
    createSlider(simulation, {
        name: "simulation_speed",
        label: "Control time:",
        initial: 1,
        min: -1, minLabel: "Forward",
        max: 1, maxLabel: "Backward",
    });
    
    createSlider(simulation, {
        name: "particle_count",
        label: "Number of particles:",
        initial: 91,
        min: 1, minLabel: "1",
        max: 200, maxLabel: "200",
    });
    
    createSlider(simulation, {
        name: "radiusScaling",
        label: "Particle size:",
        initial: 0.08,
        min: 0.01, minLabel: "Tiny",
        max: 0.1, maxLabel: "Huge",
    });
    
    createSlider(simulation, {
        name: "gravity_acceleration",
        label: "Gravity:",
        initial: 0,
        min: 0, minLabel: "None",
        max: 1e-3, maxLabel: "Strong",
        function: function(g) {
            return vec2.fromValues(0, -g);
        },
    });
    
    createSlider(simulation, {
        name: "box_size",
        label: "Box Size:",
        initial: 500,
        min: 20, minLabel: "Tiny",
        max: 1000, maxLabel: "Huge",
    });
    
    // set up simulation
    simulation.renderer = createRenderer(simulation.canvas);
    
    updateBounds(simulation);
    updateParticleCount(simulation, simulation.parameters.particle_count);
    updateTrajectory(simulation);
    
    simulation.updateFunction = function(time) {
        updateSimulation(simulation.updateFunction, simulation, time);
    };
    
    simulation.requestFrameId = window.requestAnimationFrame(simulation.updateFunction);
    
    return simulation;
}

function pauseSimulation(simulation)
{
    if (simulation.requestFrameId)
    {
        window.cancelAnimationFrame(simulation.requestFrameId);
        simulation.requestFrameId = undefined;
    }
}

function resumeSimulation(simulation)
{
    if (! simulation.requestFrameId)
    {
        previous_time = 0;
        simulation.requestFrameId = window.requestAnimationFrame(simulation.updateFunction);
    }
}

function updateBounds(simulation) {

    // retina stuff
    var canvasWidth = simulation.canvas.width;
    var canvasHeight = simulation.canvas.height;

    simulation.canvas.style.width = canvasWidth + "px";
    simulation.canvas.style.height = canvasHeight + "px";

    var devicePixelRatio = window.devicePixelRatio || 1;
    simulation.canvas.width = canvasWidth * devicePixelRatio;
    simulation.canvas.height = canvasHeight * devicePixelRatio;

    // boxes

    var aspectRatio = simulation.canvas.width / simulation.canvas.height;
    var origin = vec2.fromValues(0, 0);
    
    var box_bounds = simulation.box_bounds;
    box_bounds.setCenterWidthHeight(
        origin, 2*aspectRatio, 2
    );
    
    var radiusScaling = simulation.parameters.radiusScaling;
    simulation.collision_bounds.setCenterWidthHeight(
        origin, 2*(aspectRatio - radiusScaling), 2*(1 - radiusScaling)
    );

    simulation.right_rect.setLeftTopRightBottom(
            box_bounds.center[0], box_bounds.top,
            box_bounds.right, box_bounds.bottom);
    simulation.left_rect.setLeftTopRightBottom(
            box_bounds.left, box_bounds.top,
            box_bounds.center[0], box_bounds.bottom);

    simulation.quadTree = new Quadtree(box_bounds);

    resizeRenderer(simulation.renderer);

    draw(simulation);
}

function lennardJonesEnergy(invDistance, bondEnergy, separation)
{
    // TODO: truncate and shift, see wikipedia
    var a = separation * invDistance;
    var a6 = Math.pow(a, 6);
    var shape = a6*a6 - 2*a6;
    return bondEnergy * shape;
}

function lennardJonesForce(invDistance, bondEnergy, separation)
{
    var a = separation * invDistance;
    var a6 = Math.pow(a, 6);
    var shape = 12 * invDistance * (a6*a6 - a6);
    return bondEnergy * shape;
}

// Simulation


function draw(simulation)
{
    clearRenderer(simulation.renderer);

    // update trajectory
    if (simulation.trajectory_enabled)
    {
        trajectory.push(simulation.particles[0].position[0], simulation.particles[0].position[1]);
        drawTrajectory(simulation.trajectory, simulation.particles[0].color);
    }

    drawParticles(simulation.renderer, simulation.particles, simulation.parameters.radiusScaling);
}

var updateSimulation = function(){

  var relative_position = vec2.create(); 
  
  var total_momentum = vec2.create();
  var wall_normal = vec2.create();
  var projection = vec2.create();

  return function(updateFunction, simulation, time)
  {
      var elapsed = time - simulation.previousTime;
      if ((elapsed > 100) || (elapsed <= 0))
      {
          elapsed = simulation.parameters.frame_duration;
      }
      var slowingFactor = 0.01;
      var dt = elapsed * simulation.parameters.simulation_speed * slowingFactor;
      previous_time = time;

      var total_energy = 0;
      var total_pressure = 0;
      vec2.set(total_momentum, 0, 0);
      var color_counts = {};
      
      var mass = 1;
      
      var particles = simulation.particles;
      var particleCount = simulation.particleCount;

      for (var particleIndex = 0;
          particleIndex < particleCount;
          ++particleIndex)
      {
          var particle = particles[particleIndex];
          
          // Scale velocities with delta temperature
          
          vec2.scale(particle.velocity, particle.velocity, simulation.parameters.delta_temperature);
          
          // velocity verlet
          
          vec2.scaleAndAdd(particle.velocity, particle.velocity, particle.acceleration, 0.5 * dt);
          vec2.scaleAndAdd(particle.position, particle.position, particle.velocity, dt);
          
          // set up acceleration before next loop
          vec2.copy(particle.acceleration, simulation.parameters.gravity_acceleration);
      }

      // Calculate forces
      
      for (var i = 0; i < particleCount; ++i)
      {
          var particle = particles[i];
          
          for (var j = 0; j < i; ++j)
          {
              var otherParticle = particles[j];
              // TODO: use quadtree with given cutoff distance
              
              var bondEnergy = 0.0001;
              var separation = simulation.parameters.radiusScaling * (particle.radius + otherParticle.radius);
              
              vec2.subtract(relative_position, otherParticle.position, particle.position);
              var invDistance = 1 / vec2.length(relative_position);
              var force = lennardJonesForce(invDistance, bondEnergy, separation);
              total_energy += lennardJonesEnergy(invDistance, bondEnergy, separation);
              
              var acceleration_direction = vec2.normalize(relative_position, relative_position);
              var acceleration_magnitude = force / mass;
              vec2.scaleAndAdd(particle.acceleration, particle.acceleration, acceleration_direction, - acceleration_magnitude);
              vec2.scaleAndAdd(otherParticle.acceleration, otherParticle.acceleration, acceleration_direction, acceleration_magnitude);
          }
      }
      
      for (var particleIndex = 0;
          particleIndex < particleCount;
          ++particleIndex)
      {
          var particle = particles[particleIndex];
          
          // finish velocity verlet
          vec2.scaleAndAdd(particle.velocity, particle.velocity, particle.acceleration, 0.5 * dt);
          
          // calculate quantities
          if(simulation.left_rect.containsPoint(particle.position))
          {
              color_counts[particle.color.name] = 1 + (color_counts[particle.color.name] || 0);
          }
          total_energy += 0.5*vec2.squaredLength(particle.velocity);
          total_energy += - vec2.dot(particle.position, simulation.parameters.gravity_acceleration);
          
          vec2.scaleAndAdd(total_momentum, total_momentum, particle.velocity, mass);
          
          
          // Collision with wall
          
          var collision_bounds = simulation.collision_bounds;

          if (! collision_bounds.containsPoint(particle.position))
          {
              var overlap;

              if (particle.position[0] < collision_bounds.left)
              {
                  overlap = collision_bounds.left - particle.position[0];
                  vec2.set(wall_normal, 1, 0);
              }
              else if (particle.position[0] > collision_bounds.right)
              {
                  overlap = particle.position[0] - collision_bounds.right;
                  vec2.set(wall_normal, -1, 0);
              }
              else if (particle.position[1] < collision_bounds.top)
              {
                  overlap = collision_bounds.top - particle.position[1];
                  vec2.set(wall_normal, 0, 1);
              }
              else if (particle.position[1] > collision_bounds.bottom)
              {
                  overlap = particle.position[1] - collision_bounds.bottom;
                  vec2.set(wall_normal, 0, -1);
              }

              // Move out of overlap

              vec2.scaleAndAdd(particle.position, particle.position, wall_normal, overlap);

              // Reflect velocity

              vec2.projectOntoNormal(projection, particle.velocity, wall_normal);
              vec2.scaleAndAdd(particle.velocity, particle.velocity, projection, -2);

              total_pressure += vec2.length(projection);
          }
      }


      // Collision with other particles
      if (simulation.parameters.collision_enabled)
      {
          if (quadtree_enabled)
          {
              quadtree.clear();
              for (var particleIndex = 0;
                  particleIndex < particles.length;
                  ++particleIndex)
              {
                  var particle = particles[particleIndex];
                  particle.updateBounds();
                  quadtree.add(particle);
              }
              quadtree.collide_all(collide);
          }
          else
          {
              for (var i = 0; i < particleCount; ++i)
              {
                  for (var j = 0; j < i; ++j)
                  {
                      collide(particles[i], particles[j]);
                  }
              }
          }
      }

      // Drawing

      draw(simulation);

      // Measurements

      simulation.runningPressure.push(total_pressure);
      simulation.runningTime.push(time)
      if (simulation.runningPressure.length > simulation.parameters.pressure_window_size)
      {
          simulation.runningPressure.shift();
          var initial_time = simulation.runningTime.shift();
      }
      else
      {
          var initial_time = simulation.runningTime[0];
      }

      var average_pressure = sum(simulation.runningPressure) / (time - initial_time);
      
      document.getElementById("pressure").value = average_pressure.toExponential(2);
      document.getElementById("energy").value = total_energy.toExponential(2);
      document.getElementById("momentum").value =
          ["(", total_momentum[0].toExponential(2),
           ", ", total_momentum[1].toExponential(2), ")"].join("");
      var color_count_string_array = [];
      var entropy = 0;
      for (var color in color_counts)
      {
          if (color_counts.hasOwnProperty(color))
          {
              var color_count = color_counts[color];
              var p = color_count/particles.length;
              entropy = microstate_entropy(p) + microstate_entropy(1 - p);
              color_count_string_array.push(color, ": ", color_count, " ");
          }
      }
      document.getElementById("color").value = color_count_string_array.join("");
      document.getElementById("entropy").value = entropy.toExponential(2);

      if (simulation.running)
      {
          simulation.requestFrameId = window.requestAnimationFrame(updateFunction);
      }
  }
}();

var collide = function(){

  var relative_position = vec2.create();
  var relative_velocity = vec2.create();

  return function(particle1, particle2)
  {
      vec2.subtract(relative_position, particle1.position, particle2.position);
      var quadrance = vec2.squaredLength(relative_position);
      if (quadrance < squared(2*radiusScaling))
      {
          var distance_between_centers = Math.sqrt(quadrance);
          var overlap = 2*radiusScaling - distance_between_centers;
          var normal = vec2.scale(relative_position, relative_position, 1 / distance_between_centers);

          // Move out of overlap
          // TODO: improve to perform correct collision
          // TODO: use a continuous force instead of hard spheres

          vec2.scaleAndAdd(particle1.position, particle1.position, normal, overlap / 2);
          vec2.scaleAndAdd(particle2.position, particle2.position, normal, - overlap / 2);

          // Elastic collision

          vec2.subtract(relative_velocity, particle1.velocity, particle2.velocity);
          var delta_velocity = vec2.projectOntoNormal(relative_velocity, relative_velocity, normal);
          vec2.sub(particle1.velocity, particle1.velocity, delta_velocity);
          vec2.add(particle2.velocity, particle2.velocity, delta_velocity);
      }
  }
}();

createSimulation("simulation", 500, 400);


</script>

</html>
