<!DOCTYPE html>
<html>
<head>
    <title>Dynamic Thermodynamics</title>
    <script src="gl-matrix.js" type="text/javascript" charset="utf-8"></script>
    <script src="functions.js" type="text/javascript"></script>
    <script src="gl.js" type="text/javascript" charset="utf-8"></script>
    <!-- <script src="canvas.js" type="text/javascript" charset="utf-8"></script> -->
</head>
<body>
    <canvas id="canvas" width="500" height="400" style="border:1px solid black;"></canvas>
    <p>
        Energy = <output id="energy">?</output> (conserved) <br>
        Momentum = <output id="momentum">?</output> <br>
        Pressure = <output id="pressure">?</output> <br>
        Colors in left half = <output id="color">?</output> <br>
        Entropy = <output id="entropy">?</output> <br>
    </p>
    <p>
        Control time: <br>
        Backwards <input id="simulation_speed" type="range" value="1" min="-1" max="1" step="0.001" style="width: 300px;"> Forwards
    </p>
    <p>
        Number of particles: <br>
        1 <input id="ball_count" type="range" value="2", min="0", max="3", step="0.001"> 1000
    </p>
    <p>
        Particle radius: <br>
        1 <input id="ball_radius" type="range" value="3", min="1", max="10", step="0.001"> 10
    </p>
    <p>
        Gravity: <br>
        None <input id="gravity" type="range" value="0", min="0", max="0.0001", step="0.000001"> Strong
    </p>
    <p>
        Box size: <br>
        Tiny <input id="box_size" type="range" value="500", min="20", max="1000", step="0.001"> Huge
    </p>
    <p>
        Reset simulation to 
        <input type="button" value="Uniform" onclick="init(uniform_position, uniform_velocity, one_color)">
        <input type="button" value="Grouped" onclick="init(grouped_position, uniform_velocity, one_color)">
        <input type="button" value="Falling" 
            onclick="init(grouped_position, identical_velocity, one_color)">
        <input type="button" value="Two colors" 
            onclick="init(halves_position, uniform_velocity, two_colors)">
    </p>
    <p>
        <label for="collision">Collision</label><input type="checkbox" id="collision">
        <label for="quadtree">Quadtree</label><input type="checkbox" id="quadtree" checked>
    </p>
</body>

<script>

// Event handling

document.getElementById("simulation_speed").addEventListener("input", function() {
    simulation_speed = Number(this.value);
});

document.getElementById("collision").addEventListener("change", function(){
    collision_checking = this.checked;
});

document.getElementById("quadtree").addEventListener("change", function(){
    using_quadtree = this.checked;
});

document.getElementById("gravity").addEventListener("input", function(){
    var strength = Number(this.value);
    var angle = 0;
    vec2.set(gravity_acceleration, strength * Math.sin(angle), - strength * Math.cos(angle));
})

document.getElementById("box_size").addEventListener("input", function(){
    canvas.width = Number(this.value);
    update_bounds();
})

document.getElementById("ball_count").addEventListener("input", function(){
    ball_count = Math.pow(10, Number(this.value));
    // TODO: do not reset
    init(uniform_position, uniform_velocity, one_color);
})

document.getElementById("ball_radius").addEventListener("input", function(){
    ball_radius = Number(this.value);
    update_bounds();
})

// Pause when switching tabs, seems reasonable

document.addEventListener('visibilitychange', function(event) {
    if (document.hidden) {
        pause();
    } else {
        resume();
    }
});

// Pause when switching windows, annoying during development

// window.addEventListener("blur", function(){
//     pause();
// });
// window.addEventListener("focus", function(){
//     resume();
// });

// Constants

var tau = 2*Math.PI;
var canvas = document.getElementById("canvas");

var max_speed = 0.1;
var ball_count = 100;
var ball_radius = 3;
var running = true;
var initially_together = true;
var initially_falling = false;
var collision_checking = false;
var gravity_acceleration = vec2.create();
var pressure_window_size = 1000;
var using_quadtree = false;
var frame_duration = 33;

var collision_bounds = new Rect();
var canvas_bounds = new Rect();
var left_rect = new Rect();
var right_rect = new Rect();
                                    
                                              
// Simulation state

var balls;
var previous_time;
var simulation_speed = 1;
var request_frame_id;
var running_pressure = [];
var running_time = [];
var quadtree;

// Initialization

function grouped_position(ball_index, ball_count)
{
    var small_centered_rect = new Rect().setCenterWidthHeight(collision_bounds.center, 100, 100);
    return randomPointInRect(small_centered_rect);
}

function uniform_position(ball_index, ball_count)
{
    return randomPointInRect(collision_bounds);
}

function halves_position(ball_index, ball_count)
{
    if (ball_index < ball_count / 2)
    {
        return randomPointInRect(left_rect);
    }
    else
    {
        return randomPointInRect(right_rect);
    }
}

function uniform_velocity(ball_index, ball_count)
{
    var speed = random_in_interval(0, max_speed);
    var angle = random_in_interval(0, tau);
    return vec2.fromValues(speed * Math.cos(angle), speed * Math.sin(angle));
}

function identical_velocity(ball_index, ball_count) 
{
    return vec2.fromValues(0, -max_speed);
}

function one_color(ball_index, ball_count) 
{
    return {name: "black", rgba: [0, 0, 0, 1]};
}

function two_colors(ball_index, ball_count)
{
    if (ball_index < ball_count / 2)
    {
        return {name: "blue", rgba: [0, 0, 1, 1]};
    }
    else
    {
        return {name: "red", rgba: [1, 0, 0, 1]};
    }
}

var Ball = function(position, velocity, color)
{
    this.position = position || vec2.create();
    this.velocity = velocity || vec2.create();
    this.color    = color    || {name: "black", rgba: [0, 0, 0, 1]};
    this.bounds   = new Rect();
}

Ball.prototype.updateBounds = function() 
{
    this.bounds.setCenterWidthHeight(this.position, ball_radius*2, ball_radius*2);
    return this.bounds;
}

function init(position_function, velocity_function, color_function) 
{
    if (request_frame_id) {
        window.cancelAnimationFrame(request_frame_id);
        request_frame_id = undefined;
    }

    update_bounds();
    balls = [];
    for (var ball_index = 0; ball_index < ball_count; ball_index++) {
        var ball = new Ball(
            position_function(ball_index, ball_count), 
            velocity_function(ball_index, ball_count),
            color_function(ball_index, ball_count)
        );
        balls.push(ball);
    }
    
    previous_time = 0;
    request_frame_id = window.requestAnimationFrame(update);
}

function pause() 
{
    if (request_frame_id)
    {
        window.cancelAnimationFrame(request_frame_id);
        request_frame_id = undefined;
    }
}

function resume()
{
    if (!request_frame_id)
    {
        previous_time = 0;
        window.requestAnimationFrame(update);
    }
}

function update_bounds() {
    collision_bounds.setLeftTopRightBottom(
        ball_radius, ball_radius, 
        canvas.width - ball_radius, canvas.height - ball_radius
    );
    
    canvas_bounds.setLeftTopWidthHeight(
        0, 0, canvas.width, canvas.height
    );
    
    right_rect.setLeftTopRightBottom(
            canvas_bounds.center[0], canvas_bounds.top, 
            canvas_bounds.right, canvas_bounds.bottom);     
    left_rect.setLeftTopRightBottom(
            canvas_bounds.left, canvas_bounds.top, 
            canvas_bounds.center[0], canvas_bounds.bottom);
    
    quadtree = new Quadtree(canvas_bounds);  
    
    resize_canvas();
}
                             
// Simulation
var collide = function(){
  
  var relative_position = vec2.create();
  var relative_velocity = vec2.create();
  
  return function(ball1, ball2)
  {
      vec2.subtract(relative_position, ball1.position, ball2.position);
      var quadrance = vec2.sqrLen(relative_position);
      if (quadrance < squared(2*ball_radius)) 
      {
          var distance_between_centers = Math.sqrt(quadrance);
          var overlap = 2*ball_radius - distance_between_centers;
          var normal = vec2.scale(relative_position, relative_position, 1 / distance_between_centers);
    
          // Move out of overlap
          // TODO: improve to perform correct collision
    
          vec2.scaleAndAdd(ball1.position, ball1.position, normal, overlap / 2);
          vec2.scaleAndAdd(ball2.position, ball2.position, normal, - overlap / 2);
    
          // Elastic collision

          vec2.subtract(relative_velocity, ball1.velocity, ball2.velocity);
          var delta_velocity = vec2.projectOntoNormal(relative_velocity, relative_velocity, normal);
          vec2.sub(ball1.velocity, ball1.velocity, delta_velocity);
          vec2.add(ball2.velocity, ball2.velocity, delta_velocity);
      }
  }
}();

var update = function(){
  
  var total_momentum = vec2.create();
  var wall_normal = vec2.create();
  var projection = vec2.create();
  
  return function(time) 
  {
      var elapsed = time - previous_time;
      if ((elapsed > 100) || (elapsed <= 0))
      {
          elapsed = frame_duration;
      }
      var dt = elapsed * simulation_speed;
      previous_time = time;
    
      clear_canvas();
    
      var total_energy = 0;
      var total_pressure = 0;
      vec2.set(total_momentum, 0, 0);
      var color_counts = {};

      drawBalls(balls, ball_radius);
    
      for (var i = 0; i < balls.length; ++i)
      {
          var ball = balls[i];
      
          vec2.scaleAndAdd(ball.position, ball.position, ball.velocity, dt);
          vec2.scaleAndAdd(ball.position, ball.position, gravity_acceleration, 0.5*dt*dt);
          vec2.scaleAndAdd(ball.velocity, ball.velocity, gravity_acceleration, dt);
        
          total_energy += 0.5*vec2.sqrLen(ball.velocity) - vec2.dot(ball.position, gravity_acceleration);
          vec2.add(total_momentum, total_momentum, ball.velocity);
        
          if(left_rect.containsPoint(ball.position))
          {
              color_counts[ball.color.name] = 1 + (color_counts[ball.color.name] || 0);
          }
      }
    
      for (var i = 0; i < balls.length; ++i)
      {
          var ball = balls[i];
          
          // Collision with wall
        
          if (! collision_bounds.containsPoint(ball.position))
          {
              var overlap;

              if (ball.position[0] < collision_bounds.left)
              {
                  overlap = collision_bounds.left - ball.position[0];
                  vec2.set(wall_normal, 1, 0);
              }
              else if (ball.position[0] > collision_bounds.right)
              {
                  overlap = ball.position[0] - collision_bounds.right;
                  vec2.set(wall_normal, -1, 0);
              }
              else if (ball.position[1] < collision_bounds.top)
              {
                  overlap = collision_bounds.top - ball.position[1];
                  vec2.set(wall_normal, 0, 1);
              }
              else if (ball.position[1] > collision_bounds.bottom)
              {
                  overlap = ball.position[1] - collision_bounds.bottom;
                  vec2.set(wall_normal, 0, -1);
              }
            
              // Move out of overlap
            
              vec2.scaleAndAdd(ball.position, ball.position, wall_normal, overlap);
            
              // Reflect velocity
            
              vec2.projectOntoNormal(projection, ball.velocity, wall_normal);
              vec2.scaleAndAdd(ball.velocity, ball.velocity, projection, -2);
            
              total_pressure += vec2.length(projection);
          }
      }
    
    
      // Collision with other balls
      if (collision_checking)
      {
          if (using_quadtree)
          {
              quadtree.clear();
              for (var i = 0; i < balls.length; ++i)
              {
                  var ball = balls[i];
                  ball.updateBounds();
                  quadtree.add(ball);
              }
              quadtree.collide_all(collide);
          }
          else
          {
              for (var i = 0; i < balls.length; ++i)
              {
                  for (var j = 0; j < i; ++j)
                  {
                      collide(balls[i], balls[j]);
                  }
              }
          }
      }
    
      // Measurements
    
      running_pressure.push(total_pressure);
      running_time.push(time)
      if (running_pressure.length > pressure_window_size)
      {
          running_pressure.shift();
          var initial_time = running_time.shift();
      }
      else
      {
          var initial_time = running_time[0];
      }

      var average_pressure = sum(running_pressure) / (time - initial_time);
      document.getElementById("pressure").value = average_pressure.toExponential(2);
      document.getElementById("energy").value = total_energy.toExponential(2);
      document.getElementById("momentum").value = 
          ["(", total_momentum[0].toExponential(2), 
           ", ", total_momentum[1].toExponential(2), ")"].join("");
      var color_count_string_array = [];
      var entropy = 0;
      for (var color in color_counts) 
      {
          if (color_counts.hasOwnProperty(color)) 
          {
              var color_count = color_counts[color];
              var p = color_count/ball_count;
              entropy = microstate_entropy(p) + microstate_entropy(1 - p);
              color_count_string_array.push(color, ": ", color_count, " ");
          }
      }
      document.getElementById("color").value = color_count_string_array.join("");
      document.getElementById("entropy").value = entropy.toExponential(2);
    
      if (running) 
      {
          request_frame_id = window.requestAnimationFrame(update);
      }
  }
}();


initGraphics(canvas);
init(uniform_position, uniform_velocity, one_color)

</script>

</html>