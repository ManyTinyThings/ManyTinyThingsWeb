<!DOCTYPE html>
<html>
<head>
    <title>Dynamic Thermodynamics</title>
    <meta name="viewport" content="width=device-width">
    <script src="gl-matrix.js" type="text/javascript" charset="utf-8"></script>
    <script src="functions.js" type="text/javascript"></script>
    <script src="gl.js" type="text/javascript" charset="utf-8"></script>
    <!-- <script src="canvas.js" type="text/javascript" charset="utf-8"></script> -->
    <style type="text/css" media="screen">
        body {
            width: 500px;
            margin: 10px auto;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            width: 300px;
        }
        
        input[type="range"]::-webkit-slider-runnable-track {
            height: 5px;
            background: #ddd;
            border: none;
            border-radius: 3px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: black;
            margin-top: -7.5px;
        }
        
        input[type=range]:focus {
            outline: none;
        }
        
        #canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="500" height="400"></canvas>
    <p>
        Energy = <output id="energy">?</output> (conserved) <br>
        Momentum = <output id="momentum">?</output> <br>
        Pressure = <output id="pressure">?</output> <br>
        Colors in left half = <output id="color">?</output> <br>
        Entropy = <output id="entropy">?</output> <br>
    </p>
    <p>
        Reset simulation to 
        <input type="button" value="Uniform" onclick="init(uniformBallGenerator)">
        <input type="button" value="Grouped" onclick="init(groupedBallGenerator)">
        <input type="button" value="Falling" onclick="init(fallingBallGenerator)">
        <input type="button" value="Two colors" onclick="init(twoColorBallGenerator)">
    </p>
    <p>
        Control time: <br>
        Backwards <input id="simulation_speed" type="range" value="1" min="-1" max="1" step="0.001"> Forwards
    </p>
    <p>
        Number of particles: <br>
        1 <input id="ball_count" type="range" value="2", min="0", max="3", step="0.001"> 1000
    </p>
    <p>
        Particle radius: <br>
        Tiny <input id="ball_radius" type="range" value="0.02", min="0.01", max="0.1", step="0.001"> Huge
    </p>
    <p>
        Gravity: <br>
        None <input id="gravity" type="range" value="0", min="0", max="2e-6", step="1e-8"> Strong
    </p>
    <p>
        Box size: <br>
        Tiny <input id="box_size" type="range" value="500", min="20", max="1000", step="0.001"> Huge
    </p>
    <p>
        <label for="collision">Collision</label><input type="checkbox" id="collision" checked>
        <label for="quadtree">Quadtree</label><input type="checkbox" id="quadtree" checked>
    </p>
</body>

<script>

// Event handling

document.getElementById("simulation_speed").addEventListener("input", function() {
    simulation_speed = Number(this.value);
});

document.getElementById("collision").addEventListener("change", function(){
    collision_checking = this.checked;
});

document.getElementById("quadtree").addEventListener("change", function(){
    using_quadtree = this.checked;
    quadtree.clear();
});

document.getElementById("gravity").addEventListener("input", function(){
    var strength = Number(this.value);
    var angle = 0;
    vec2.set(gravity_acceleration, strength * Math.sin(angle), - strength * Math.cos(angle));
})

document.getElementById("box_size").addEventListener("change", function(){
    canvasWidth = Number(this.value);
    canvas.style.marginLeft = ((document.body.clientWidth - canvasWidth) / 2) + "px";
    update_bounds();
})

document.getElementById("ball_count").addEventListener("input", function(){
    ballCount = Math.round(Math.pow(10, Number(this.value)));
    updateBallCount(ballCount);
})

document.getElementById("ball_radius").addEventListener("input", function(){
    ball_radius = Number(this.value);
    update_bounds();
})


var canvas = document.getElementById("canvas");
var canvasWidth = canvas.width;
var canvasHeight = canvas.height;

canvas.addEventListener("click", function(){
    if (request_frame_id)
    {
        pause();
    }
    else
    {
        resume();
    }
})

// Pause when switching tabs, seems reasonable

document.addEventListener('visibilitychange', function(event) {
    if (document.hidden) {
        pause();
    } else {
        resume();
    }
});

// Pause when switching windows, annoying during development

// window.addEventListener("blur", function(){
//     pause();
// });
// window.addEventListener("focus", function(){
//     resume();
// });

// Variables

var tau = 2*Math.PI;

var max_speed = 0.001;
var ball_radius = 0.02;
var running = true;
var initially_together = true;
var initially_falling = false;
var collision_checking = true;
var gravity_acceleration = vec2.create();
var pressure_window_size = 1000;
var using_quadtree = true;
var frame_duration = 33;

var box_bounds = new Rect();
var collision_bounds = new Rect();
var left_rect = new Rect();
var right_rect = new Rect();
                                    
                                              
// Simulation state

var ballGenerator = uniformBallGenerator;
var ballCount = 100;
var balls;
var previous_time;
var simulation_speed = 1;
var request_frame_id;
var running_pressure = [];
var running_time = [];
var quadtree;


// Ball object

var Ball = function(position, velocity, color)
{
    this.position = position || vec2.create();
    this.velocity = velocity || vec2.create();
    this.color    = color    || {name: "black", rgba: [0, 0, 0, 1]};
    this.bounds   = new Rect();
}

Ball.prototype.updateBounds = function() 
{
    this.bounds.setCenterWidthHeight(this.position, ball_radius*2, ball_radius*2);
    return this.bounds;
}

// Initialization

function grouped_position(ballIndex)
{
    var small_centered_rect = new Rect().setCenterWidthHeight(
        collision_bounds.center, collision_bounds.width / 5, collision_bounds.height / 5
    );
    return randomPointInRect(small_centered_rect);
}

function uniform_position(ballIndex)
{
    return randomPointInRect(collision_bounds);
}

function halves_position(ballIndex)
{
    if (ballIndex % 2 == 0)
    {
        return randomPointInRect(left_rect);
    }
    else
    {
        return randomPointInRect(right_rect);
    }
}

function uniform_velocity(ballIndex)
{
    var speed = random_in_interval(0, max_speed);
    var angle = random_in_interval(0, tau);
    return vec2.fromValues(speed * Math.cos(angle), speed * Math.sin(angle));
}

function identical_velocity(ballIndex) 
{
    return vec2.fromValues(0, -max_speed);
}

function one_color(ballIndex) 
{
    return {name: "black", rgba: [0, 0, 0, 1]};
}

function two_colors(ballIndex)
{
    if (ballIndex % 2 == 0)
    {
        return {name: "blue", rgba: [0, 0, 1, 1]};
    }
    else
    {
        return {name: "red", rgba: [1, 0, 0, 1]};
    }
}

// ball generators

function uniformBallGenerator(ballIndex)
{
    return new Ball(
                uniform_position(ballIndex), 
                uniform_velocity(ballIndex),
                one_color(ballIndex)
            );
}

function groupedBallGenerator(ballIndex)
{
    return new Ball(
                grouped_position(ballIndex), 
                uniform_velocity(ballIndex),
                one_color(ballIndex)
            );
}

function fallingBallGenerator(ballIndex)
{
    return new Ball(
                grouped_position(ballIndex), 
                identical_velocity(ballIndex),
                one_color(ballIndex)
            );
}

function twoColorBallGenerator(ballIndex)
{
    return new Ball(
                halves_position(ballIndex), 
                uniform_velocity(ballIndex),
                two_colors(ballIndex)
            );
}

function updateBallCount(newBallCount)
{
    var ballCount = balls.length;
    if (newBallCount == ballCount)
    {
        return;
    }
    else if (newBallCount < ballCount)
    {
        balls.splice(newBallCount, Number.MAX_VALUE);
    }
    else
    {
        for (var ballIndex = ballCount;
             ballIndex < newBallCount;
             ++ballIndex)
        {
            balls.push(ballGenerator(ballIndex))
        }
    }
    ballCount = newBallCount;
}

function init(newBallGenerator) 
{
    if (request_frame_id) {
        window.cancelAnimationFrame(request_frame_id);
        request_frame_id = undefined;
    }

    update_bounds();
    
    ballGenerator = newBallGenerator || ballGenerator;
    balls = [];
    updateBallCount(ballCount);
    
    previous_time = 0;
    request_frame_id = window.requestAnimationFrame(update);
}

function pause() 
{
    if (request_frame_id)
    {
        window.cancelAnimationFrame(request_frame_id);
        request_frame_id = undefined;
    }
}

function resume()
{
    if (!request_frame_id)
    {
        previous_time = 0;
        window.requestAnimationFrame(update);
    }
}

function update_bounds() {
    
    // retina stuff
    
    canvas.style.width = canvasWidth + "px";
    canvas.style.height = canvasHeight + "px";

    var devicePixelRatio = window.devicePixelRatio || 1;
    canvas.width = canvasWidth * devicePixelRatio;
    canvas.height = canvasHeight * devicePixelRatio;
    
    // boxes
    
    var aspectRatio = canvas.width / canvas.height;
    var origin = vec2.fromValues(0, 0);
    
    box_bounds.setCenterWidthHeight(
        origin, 2*aspectRatio, 2
    );
    
    collision_bounds.setCenterWidthHeight(
        origin, 2*(aspectRatio - ball_radius), 2*(1 - ball_radius)
    );
    
    right_rect.setLeftTopRightBottom(
            box_bounds.center[0], box_bounds.top,
            box_bounds.right, box_bounds.bottom);
    left_rect.setLeftTopRightBottom(
            box_bounds.left, box_bounds.top,
            box_bounds.center[0], box_bounds.bottom);
    
    quadtree = new Quadtree(box_bounds);
    
    resize_canvas();
}
                             
// Simulation
var collide = function(){
  
  var relative_position = vec2.create();
  var relative_velocity = vec2.create();
  
  return function(ball1, ball2)
  {
      vec2.subtract(relative_position, ball1.position, ball2.position);
      var quadrance = vec2.sqrLen(relative_position);
      if (quadrance < squared(2*ball_radius)) 
      {
          var distance_between_centers = Math.sqrt(quadrance);
          var overlap = 2*ball_radius - distance_between_centers;
          var normal = vec2.scale(relative_position, relative_position, 1 / distance_between_centers);
    
          // Move out of overlap
          // TODO: improve to perform correct collision
    
          vec2.scaleAndAdd(ball1.position, ball1.position, normal, overlap / 2);
          vec2.scaleAndAdd(ball2.position, ball2.position, normal, - overlap / 2);
    
          // Elastic collision

          vec2.subtract(relative_velocity, ball1.velocity, ball2.velocity);
          var delta_velocity = vec2.projectOntoNormal(relative_velocity, relative_velocity, normal);
          vec2.sub(ball1.velocity, ball1.velocity, delta_velocity);
          vec2.add(ball2.velocity, ball2.velocity, delta_velocity);
      }
  }
}();

var update = function(){
  
  var total_momentum = vec2.create();
  var wall_normal = vec2.create();
  var projection = vec2.create();
  
  return function(time) 
  {
      var elapsed = time - previous_time;
      if ((elapsed > 100) || (elapsed <= 0))
      {
          elapsed = frame_duration;
      }
      var dt = elapsed * simulation_speed;
      previous_time = time;
    
      clear_canvas();
    
      var total_energy = 0;
      var total_pressure = 0;
      vec2.set(total_momentum, 0, 0);
      var color_counts = {};

      drawBalls(balls, ball_radius);
    
      for (var ballIndex = 0; 
          ballIndex < balls.length; 
          ++ballIndex)
      {
          var ball = balls[ballIndex];
      
          vec2.scaleAndAdd(ball.position, ball.position, ball.velocity, dt);
          vec2.scaleAndAdd(ball.position, ball.position, gravity_acceleration, 0.5*dt*dt);
          vec2.scaleAndAdd(ball.velocity, ball.velocity, gravity_acceleration, dt);
        
          total_energy += 0.5*vec2.sqrLen(ball.velocity) - vec2.dot(ball.position, gravity_acceleration);
          vec2.add(total_momentum, total_momentum, ball.velocity);
        
          if(left_rect.containsPoint(ball.position))
          {
              color_counts[ball.color.name] = 1 + (color_counts[ball.color.name] || 0);
          }
      }
    
      for (var ballIndex = 0; 
          ballIndex < balls.length; 
          ++ballIndex)
      {
          var ball = balls[ballIndex];
          
          // Collision with wall
        
          if (! collision_bounds.containsPoint(ball.position))
          {
              var overlap;

              if (ball.position[0] < collision_bounds.left)
              {
                  overlap = collision_bounds.left - ball.position[0];
                  vec2.set(wall_normal, 1, 0);
              }
              else if (ball.position[0] > collision_bounds.right)
              {
                  overlap = ball.position[0] - collision_bounds.right;
                  vec2.set(wall_normal, -1, 0);
              }
              else if (ball.position[1] < collision_bounds.top)
              {
                  overlap = collision_bounds.top - ball.position[1];
                  vec2.set(wall_normal, 0, 1);
              }
              else if (ball.position[1] > collision_bounds.bottom)
              {
                  overlap = ball.position[1] - collision_bounds.bottom;
                  vec2.set(wall_normal, 0, -1);
              }
            
              // Move out of overlap
            
              vec2.scaleAndAdd(ball.position, ball.position, wall_normal, overlap);
            
              // Reflect velocity
            
              vec2.projectOntoNormal(projection, ball.velocity, wall_normal);
              vec2.scaleAndAdd(ball.velocity, ball.velocity, projection, -2);
            
              total_pressure += vec2.length(projection);
          }
      }
    
    
      // Collision with other balls
      if (collision_checking)
      {
          if (using_quadtree)
          {
              quadtree.clear();
              for (var ballIndex = 0; 
                  ballIndex < balls.length; 
                  ++ballIndex)
              {
                  var ball = balls[ballIndex];
                  ball.updateBounds();
                  quadtree.add(ball);
              }
              quadtree.collide_all(collide);
          }
          else
          {
              for (var i = 0; i < balls.length; ++i)
              {
                  for (var j = 0; j < i; ++j)
                  {
                      collide(balls[i], balls[j]);
                  }
              }
          }
      }
    
      // Measurements
    
      running_pressure.push(total_pressure);
      running_time.push(time)
      if (running_pressure.length > pressure_window_size)
      {
          running_pressure.shift();
          var initial_time = running_time.shift();
      }
      else
      {
          var initial_time = running_time[0];
      }

      var average_pressure = sum(running_pressure) / (time - initial_time);
      document.getElementById("pressure").value = average_pressure.toExponential(2);
      document.getElementById("energy").value = total_energy.toExponential(2);
      document.getElementById("momentum").value = 
          ["(", total_momentum[0].toExponential(2), 
           ", ", total_momentum[1].toExponential(2), ")"].join("");
      var color_count_string_array = [];
      var entropy = 0;
      for (var color in color_counts) 
      {
          if (color_counts.hasOwnProperty(color)) 
          {
              var color_count = color_counts[color];
              var p = color_count/balls.length;
              entropy = microstate_entropy(p) + microstate_entropy(1 - p);
              color_count_string_array.push(color, ": ", color_count, " ");
          }
      }
      document.getElementById("color").value = color_count_string_array.join("");
      document.getElementById("entropy").value = entropy.toExponential(2);
    
      if (running) 
      {
          request_frame_id = window.requestAnimationFrame(update);
      }
  }
}();


initGraphics(canvas);
init()

</script>

</html>